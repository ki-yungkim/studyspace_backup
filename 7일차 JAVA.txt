## ----------------------------------
##	JAVA 7일차 수업
## ----------------------------------
-----------------------------------------------------------
그 동안 배운 것 키워드 

도메인 
클래스 
변수 메서드 (형식 : 선언문, 규칙 => 재정의규칙)
데이터 타입 기본형 객체형(참조형)

-- 속성변경 메서드 setter() 
-- 속성조회 메서드 getter()

일반화 Generalization
-- 객체들의 공통사항 일반호(부모클래스)설계
-- 일반화 : 표준(메서드형식, 속성목록) 
-- 상속(inheritance) :
	>> 표준화(일관성)
	>> 유지보수 편리 
	>> 확장성 
	>> 재사용성 -> 개발속도향상, 안정성 
	>> 부모 super => 자식 sub 
	>> 자식일지라도 부모의 private 멤버는 접근 불가 
	>> 객체생성 (new 절차, 생성자)
	>> 부모생성자 수행 => 자식생성자 수행 
	>> 계층적 구조
	>> 모든 클래스의 조상클래스(root class) : java.lang.Object
	>> 단일 상속 허용 
	>> Object 자동 상속 받음 => toString(), equals(Object)
 	
-- 라이브러리 >> 프레임워크 >> 패턴 >>  아키텍처 
	
-- 은닉성(encapsulation)
	>> inforamation(속성, 기능) hiding
	
-- access modifier (접근 권한)
	>> public, private(same class)
	

----------------------------------------------------------
숨은 그림 찾기 하지 말자 
오류 날때마다 다른 사람 코드 보고 비교하면 실력 그대로다  

오류가 나면 왜 오류가 났는지 적어두자 
자신만의 주석 적자 
-----------------------------------------------------------

JVM 그림 꼭 그려봐라 

찾아볼 단어!!

call by value
call by reference 


!!!!! 중요 
virtual method invocation : 
재정의한 메서드는 부모타입의 참조변수여도 실제 재정의한 자식의 재정의 매서드 호출 수행 
!!!!!

-- this 
-- super 

## ----------------------------------
## super 키워드
## ----------------------------------
- 부모 객체를 가르키는 참조변수

- 방법:
1) 부모의 멤버변수 및 멤버메서드를 가르킬때 사용
	super.부모멤버변수명;
	super.부모멤버메서드명();

2) 자식객체의 생성자에서 부모객체의 생성자 지정시 사용
	super(param데이터1, param데이터n);
	
	부모생성자를 지정하지 않으면 자동으로 super() 부여됨
	즉, 부모의 아규먼트를 받지 않는 생성자에 의해서 부모객체 생성함
	
	주의사항: 
	자식객체의 생성자의 첫번째 수행문으로 선언
	this() 와 super() 함께 사용 못함

	

## ----------------------------------
## Polymorphism (다형성):
## ----------------------------------

1. 목적 : 
	- 메서드 및 변수에 다형성을 적용하여 유지보수성, 확장성, 재사용성의 효율을 높임
	- 적용 : 멤버변수타입, 매개변수타입, 반환타입, 배열타입, 메서드 
	- 즉, 부모타입의 변수로 선언하면 모든 자식객체를 담을수 있는 저장공간
	
2. 다형성 종류
	2.1 Overloading (중복정의)
	- 같은 클래스, 또는 상속받은 메서드를 아규먼트 인자를 다르게 받도록 여러개 중복 정의
	- 메서드 이름은 동일하고,
	- 메서드의 아규먼트의 갯수, 순서, 타입은 반드시 다르게 지정해야함
	- 메서드의 반환타입, 접근제어자는 상관없음 (즉, 같아도 되고, 달라도 됨)
	
	2.2	Overriding (재정의)
	- 전제조건 : 상속 (부모로부터 물려받은 추운 겨울에 입는 밍크코트)
	- 상속받은 메서드를 서브클래스에 맞도록 코드구현로직을 변경하여 사용함
	
	- 반환타입, 메서드이름, 메서드 아규먼트 갯수, 순서, 타입은 동일해야함
	- 접근권한은 부모클래스의 권한보다 축소될 수 없음(즉, 같거나 확장은 가능함)
	
	- 예외는 부모클래스의 예외보다 확장될 수 없음(즉, 없거나, 작거나, 같은 예외를 던져야함)
	- 재정의 어노테이션(annotation) : javac 컴파일시점 재정의 규칙 위반여부 체크(규칙 미준수 컴파일 오류발생)
		>> jdk1.5 추가 
		>> @override (재정의 규칙 체크) 
	- 재정의한 메서드는 가장 마지막(sub) 재정의한 메서드로 자동 호출 수행 : virtual method invocation 
		
	2.3	부모타입으로 변수 선언 
	- 배열타입, 메서드의 매개변수 타입, 메서드의 반환타입, 단일변수타입
	- 부모타입의 참조변수로 서브객체를 reference 할 수 있음
	- 부모타입의 참조변수로는 서브객체의 멤버는 접근할 수 없음
	- 서브객체의 멤버를 접근하기 위해서는 서브객체타입으로 캐스팅하여 사용가능함
	- 예:	
		Person p = new Employee("홍길동", "인사팀", "서울시");
		p.name = "정유진"; 	// 부모의 멤버이므로 접근 가능
		p.dept = "감사팀";	// 자식멤버는 부모의 타입으로 접근 불가능하므로 컴파일오류
		Employee e = (Employee)p;
		e.dept = "감사팀"; 	// 자식타입으로 캐스팅후 자식객체의 멤버 접근 가능

	2.4	instanceof 키워드
	- 실제 메모리에 생성된 자식객체타입으로 형변환하기 전에 해당 클래스의 객체(instance) 여부 체킹하지 않으면 수행 중에 예외발생 
		>> ClassCastException 
	- 자식타입으로 캐스팅하는경우에 캐스팅하기전에 해당 객체의 인스턴스인지 검사
	- 예:  
		if (p instanceof Employee) { 
			Employee e = (Employee)p;
		} else {
			// 다른객체의 인스턴스이므로 캐스팅 오류 발생처리
		}


## ----------------------------------
## instanceof 키워드
## ----------------------------------
1. 해당객체가 클래스의 인스턴스인지 확인해서 
   인스턴스이면 true 반환 그렇지 않으면 false를 반환
   객체타입으로 형변환 하기전에 확인한후 형변환 권장

2. 사용법:
	if (부모참조변수명 instancof 서브클래스이름) {
		서브클래스이름 자식참조변수명 = (서브클래스이름)부모참조변수명;
		
		// 캐스팅을 수행한 후에는 자식의 모든 멤버를 접근 가능함
		자식참조변수명.자식멤버변수명;
		자식참조변수명.자식멤버메서드명();
	} 

3. 주의
-- 다중 if ~ eles if ~ 로 instanceof 확인시에는 
   sub-class가 앞에 나오고 뒤에 super-class가 위치되어야함

-- 	if(참조변수명 instanceof Customer) {  // 맨앞에서 다 처리하므로 뒤에 서브로 내려가지않음
		
	} else if (참조변수명 instanceof GeneralCustomer) {
	
	} else if (참조변수명 instanceof SpecialCustomer) {
	
	}
	
	
------------------------------------------------------
-- java.lang.Object 
-- toString() String 문자 반환 
-- equals(Object) boolean
	>> String 문자열 비교 


## java.lang.Object
-- 모든 클래스의 자동으로 상속된 root class
-- 주로 재정의(overriding) 메서드
-- 주로 재정의(overriding) 메서드
	1. toString() : String
	2. equals (Object) : boolean/ hashCode(): int
	
## 같은 값 비교 
-- 값1 == 값2
-- 5 == 10
-- 10 == 10

## 같은 객체 비교 
-- 객체1.equals(객체2)

-- 예시: 
	 Member dto1 = new Member("user01", ...);
	 Member dto2 = new Member ("user02", ...);
	 
	 Member dto3 = dto1;
	 
	 if(dto1과 dto2는 같은 객체??) 
	 
	 new로 했기 때문에 각각 다르게 올라간다 다른 객체 
	 
	 if (dto1.equals(dto2)) {
		// 같은 객체
	 } else {
		// 다른 객체 //출력
	 }
	 
	// 코드 1
	if (dto1.equals(dto3)) {
		// 같은 객체 //출력 
	 } else {
		// 다른 객체 
	 }
	
	같은 객체는 같은 값을 가지고 있다
	같은 참조값
	
	// 코드2 
	if (dto1 == dto3) {
	
	}else {
	
	}
	
	코드 1 = 코드 2
	같은 참조값	
	
	
	오후에 equals 재정의 
	아이디가 같으면... 으로 
	
	equals API 내용 
	
	Note that it is generally necessary to override 
	the hashCode method whenever this method is overridden,
	
	문자열 비교할 때 equals 재정의해서 해야한다 
	
	Member Id 비교해서 같으면 같은 걸로 
	equals 재정의 필요
	
	다음 주 콜렉션 
----------------------------------------------------------------------------
Usage Modifier

## ----------------------------------
## Modifier (제한자, 제어자)
## ----------------------------------
1. Access Modifier (접근 제한자)
		1) + public : universe (누구나 접근가능)
		2) # protected : sub class(상속 받으면 접근 가능)
		3)   생략 : same package (다른 패키지 접근불가)
		4) - private : same class (다른 클래스 접근불가)
		
		-- 클래스 : public, 생략(default)
		-- 멤버변수, 메서드, 생성자 : public, protected, 생략, private
		-- 지역변수 : 생략
		
2. Usage Modifier (사용 제한자)
		1) static
		2) final
		3) abstract
		4) transient
		5) synchronized
		6) ...
-----------------------------------------
3가지만 진행한다.

Usage Modifier (사용 제한자)
	(1) static : 객체생성하지 않고 멤버 사용, 공유
	(2) final : 끝
	(3) abstract : 미완성 
		

## static
-- 메모리 영역
	>> Class Area / Method Area / (static area)
	>> 프로그램 시작시 자동 로딩 ~ 프로그램 종료시까지 메모리 상주 (JVM)

-- 사용 방법: 
		>> 클래스명.class변수명 
		>> 클래스명.class메서드명(params)
		>> System.out.println (앞 대문자니까 클래스)
			out이 스태틱 변수, 객체타입 변수 
		
-- 객체 생성하지 않고 사용가능한 멤버
-- static 종류 :
	1. 멤버변수 : Class 변수 (static 멤버변수)
		>> 객체 생성 없이 사용가능 
		>> 모든 객체들이 공유 가능한 공유변수 
	2. 메서드 : Class 메서드 (static 메서드)
	3. static 블럭 초기화 
	//위 3가지 배운다.
	
	4. static inner class : 클래스 내부에 선언한 클래스 (중첩 클래스, inner class)

------------------------------------------------------------------
							7교시부터 
--------------------------------------------------------------
-- 같은 클래스
	>> 인스턴스 멤버 : 그냥 호출 사용
	public String memberID;
	public void setMemberId(Sting memberId) {
		this.memberId = memberId;
	}

// 헷갈릴 수 있다 주의!
-- class 멤버메서드(static 멤버메서드) : 
		=> static 멤버는 그냥 호출 사용가능
		=> instance 멤버는 같은 클래스에 존재해도 반드시 객체 생성 후 참조변수명.instance 멤버명 사용
-- 다른 클래스
	>> 객체 생성 후에 참조변수명.인스턴스멤버변수명, 참조변수명.인스턴스메서드명();
	Member dto = new Member();
	dto.setMemberId("aaa");
	>> class 멤버는 클래스명.class 멤버명 사용

API
Math 생성자 disable 

생성자 없는 클래스는 없다

method 들어가보면 객체 생성하지 않아도 되게 다 만들어져있다.
static

Field에 있는 PI -> final 
See Also:
Constant Field Values 누르면 상수 값 나온다.

java.lang의 System
마찬가지 다 만들어져있다 
static
 *arraycopy 참고 배열 학생 수 늘리는 것에 사용 


//코딩컨벤션 항상 주의하자

## final
-- 끝
-- 멤버변수 : 값 변경불가
-- 매개변수 : 전달값 변경 불가 => 비밀번호 변경(아이디, 기존암호, final 변경암호)       
-- 메서드  : 재정의 불가 (부분) (매서드 만든거 그대로 사용해라)		매개변수 -> 전달, 메서드-> 표준
-- 클래스  : 상속 불가  (전체)
-- 상수 선언 : public static final 타입 변수명 = 상수값;


부분적으로 하면 메서드 단위
전체로 하면 클래스 단위

API에서 String 
final 
System도 final 


## 소스파일 구조
1. package 선언문 
-- 0, 1

2. import 선언문
-- 0 ~ N

3. class 선언문 
-- 1 ~ N 
-- 하나의 소스코드 파일 안에 여러개의 class를 선언 가능 
	: 권장하지 않음, 가끔 테스트에 사용 가능 
-- 여러 개의 클래스를 선언하는 경우
	>> public 클래스는 딱 1개만 존재 가능 : 소스코드 파일 명은 반드시 public클래스명.java로 
	>> public 클래스 권한을 갖는 class가 존재하지 않으면 : 소스코드 파일명 제한이 없음(마음대로), main이 되는 클래스명.java
	

## static 
너무 많이 쓰면 메모리를 너무 많이 먹는다 
JVM이 뻗을 수 있음 
계속 쓰는 것만 static으로 


07.mms_oop
service 패키지 

------------------------------------
내일 

## abstract	

## interface 
	
둘 차이점 구분 

9 ~ 10장 예습 

설계적인 관점 

